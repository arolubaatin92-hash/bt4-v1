<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Advanced Chunked File Sender to Telegram Bot</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    body {
      font-family: 'Segoe UI', Arial, Helvetica, sans-serif;
      background: linear-gradient(to right, #c8e8fa 0%, #e2ffe6 100%);
      margin: 0;
      padding: 0;
    }
    .container {
      max-width: 480px;
      background: #fff;
      margin: 32px auto;
      padding: 32px 30px 28px;
      border-radius: 14px;
      box-shadow: 0 2px 16px rgba(52,128,255,0.10);
    }
    h1 {
      text-align: center;
      color: #42a09e;
      font-weight: 700;
      font-size: 2em;
      margin-bottom: 16px;
    }
    .label {
      font-weight: 560;
      margin-top: 14px;
      margin-bottom: 6px;
      display: block;
      color: #225568;
      font-size: 1.04em;
    }
    input[type="text"], input[type="file"] {
      width: 100%;
      font-size: 1em;
      padding: 11px 13px;
      margin-bottom: 8px;
      border: 1.5px solid #98cdff;
      border-radius: 7px;
      background: #f7fafc;
      box-sizing: border-box;
      transition: border-color .2s;
    }
    input[type="file"] {
      border: 0;
      background: transparent;
      font-size: 1em;
      padding: 0;
      margin-bottom: 8px;
    }
    button {
      background: linear-gradient(90deg, #349ccc 35%, #4fbcab 100%);
      color: #fff;
      border: none;
      border-radius: 8px;
      font-size: 1.1em;
      font-weight: 600;
      padding: 13px 10px;
      width: 100%;
      cursor: pointer;
      margin-top: 12px;
      margin-bottom: 8px;
      transition: background .16s, box-shadow .16s;
      box-shadow: 0 1px 6px #349ccc08;
    }
    button:disabled {
      background: #aed9e9;
      cursor: not-allowed;
    }
    .progress-bar-bg {
      background: #f3f3f3;
      border-radius: 9px;
      height: 28px;
      margin: 12px 0 16px;
      width: 100%;
      box-shadow: 0 1px 6px #98cdff10;
      overflow: hidden;
      border: 1px solid #b7efe6;
    }
    .progress-bar {
      height: 100%;
      transition: width 0.3s;
      background: linear-gradient(90deg, #39c8b1 0%, #3193d7 100%);
      border-radius: 9px 0 0 9px;
      width: 0%;
      font-weight: 700;
      color: #fff;
      text-align: center;
      font-size: 1em;
      line-height: 28px;
      box-shadow: 0 1px 4px #349ccc16;
    }
    .log-area {
      background: #f7f7fa;
      border-radius: 10px;
      min-height: 40px;
      font-size: .95em;
      color: #245959;
      padding: 8px 14px;
      margin-bottom: 10px;
      margin-top: 5px;
      overflow-y: auto;
      max-height: 200px;
      border-left: 3px solid #58e2e2;
    }
    .chunk-list {
      margin-top: 8px;
      margin-bottom: 8px;
    }
    .chunk-item {
      background: #e1fbfe;
      border-radius: 6px;
      padding: 8px 12px 6px 12px;
      font-size: .97em;
      margin-bottom: 6px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      box-shadow: 0 1px 6px #349ccc11;
      border-left: 4px solid #53ceb7;
    }
    .chunk-status {
      font-weight: 600;
      font-size: 1em;
    }
    .chunk-success { color: #206f2a; }
    .chunk-pending { color: #4c4c4c; }
    .chunk-failed { color: #d13747; }
    .retry-btn {
      background: #faa6a6 !important;
      color: #802a2a !important;
      padding: 7px 13px;
      border-radius: 6px;
      font-size: .93em;
      border: none;
      cursor: pointer;
      margin-left: 14px;
      min-width: 60px;
      transition: background .13s;
      box-shadow: 0 1px 3px #ffdadb23;
    }
    .retry-btn:hover { background: #f87070 !important; }
    .small-note {
      font-size: 0.97em;
      color: #5f5f6b;
      margin-top: -2px;
      margin-bottom: 10px;
    }
    .success-msg, .error-msg {
      padding: 10px 18px;
      margin-bottom: 9px;
      border-radius: 8px;
    }
    .success-msg { background: #e8ffed; color: #257537; border: 1px solid #85ff8e; }
    .error-msg { background: #fff0f1; color: #d13747; border: 1px solid #ffdae4; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Chunk & Send File to Telegram Bot</h1>

    <label class="label" for="botToken">Telegram Bot Token</label>
    <input type="text" id="botToken" placeholder="Enter Bot API token">

    <label class="label" for="chatId">Telegram Chat ID</label>
    <input type="text" id="chatId" placeholder="Enter Chat ID">

    <label class="label" for="fileInput">Select File to Chunk & Send</label>
    <input type="file" id="fileInput">
    <div class="small-note">Files are split into 2MB ZIP chunks and sent one by one. Do not use this method for extremely large files.</div>

    <button id="startBtn">Start Chunk & Upload</button>

    <div class="progress-bar-bg"><div class="progress-bar" id="progressBar">0%</div></div>

    <div class="log-area" id="logArea"></div>

    <div class="chunk-list" id="chunkList"></div>
  </div>
  <script>
    const CHUNK_SIZE = 2 * 1024 * 1024;
    let file, botToken, chatId;
    let chunkMeta = [];
    const fileInput = document.getElementById('fileInput');
    const startBtn = document.getElementById('startBtn');
    const logArea = document.getElementById('logArea');
    const chunkList = document.getElementById('chunkList');
    const progressBar = document.getElementById('progressBar');

    function log(msg, isSuccess=false, isError=false) {
      const div = document.createElement('div');
      if (isSuccess) div.className = "success-msg";
      else if (isError) div.className = "error-msg";
      div.textContent = msg;
      logArea.appendChild(div);
      logArea.scrollTop = logArea.scrollHeight;
    }

    function updateProgressBar(percent) {
      progressBar.style.width = percent + "%";
      progressBar.textContent = `${Math.round(percent)}%`;
    }

    function resetUI(clearChunks=true) {
      logArea.innerHTML = '';
      updateProgressBar(0);
      if(clearChunks) chunkList.innerHTML = '';
      chunkMeta = [];
    }

    function renderChunkList(meta) {
      chunkList.innerHTML = '';
      meta.forEach((item, idx) => {
        const wrap = document.createElement('div');
        wrap.className = 'chunk-item';
        wrap.id = `chunk_item_${idx}`;
        const left = document.createElement('span');
        left.textContent = `Chunk #${idx+1}`;
        const stat = document.createElement('span');
        stat.className = "chunk-status";
        stat.textContent = item.status;
        if(item.status === "Success") stat.classList.add("chunk-success");
        else if(item.status === "Pending") stat.classList.add("chunk-pending");
        else if(item.status === "Failed") stat.classList.add("chunk-failed");
        wrap.appendChild(left);
        wrap.appendChild(stat);

        if(item.status === "Failed") {
          const retryBtn = document.createElement('button');
          retryBtn.textContent = "Retry";
          retryBtn.className = "retry-btn";
          retryBtn.onclick = () => retryChunk(idx);
          wrap.appendChild(retryBtn);
        }
        chunkList.appendChild(wrap);
      });
    }

    // Utility: ZIP a Blob as 'chunk.bin'
    async function makeZipFromBlob(blob) {
      let zip = new JSZip();
      zip.file("chunk.bin", blob);
      const zipBlob = await zip.generateAsync({ type: "blob" });
      return zipBlob;
    }

    // Utility: Send ZIP to Telegram
    async function sendZipToTelegram(blob, idx) {
      return new Promise(async (resolve) => {
        const fd = new FormData();
        fd.append("chat_id", chatId);
        fd.append("document", blob, `chunk${idx+1}.zip`);
        const url = `https://api.telegram.org/bot${botToken}/sendDocument`;
        try {
          const resp = await fetch(url, { method: "POST", body: fd });
          const result = await resp.json();
          resolve(result.ok ? true : false);
        } catch(e) {
          resolve(false);
        }
      });
    }

    // Chunk, ZIP, Send (main logic)
    async function chunkZipAndSend() {
      resetUI();
      botToken = document.getElementById('botToken').value.trim();
      chatId = document.getElementById('chatId').value.trim();
      file = fileInput.files[0];

      if(!botToken || !chatId || !file) {
        log("Please fill in token, chat ID, and select a file.", false, true);
        return;
      }
      const chunkCount = Math.ceil(file.size / CHUNK_SIZE);
      chunkMeta = [];
      log(`Splitting "${file.name}" (${(file.size/1024/1024).toFixed(2)} MB) into ${chunkCount} x 2MB chunks...`);
      // Prepare chunk meta info
      for(let i = 0; i < chunkCount; i++) {
        chunkMeta.push({ status: "Pending", zipBlob: null });
      }
      renderChunkList(chunkMeta);
      let sentCount = 0;
      // Sequentially process chunks
      for(let i = 0; i < chunkCount; i++) {
        let start = i * CHUNK_SIZE;
        let end = Math.min((i+1)*CHUNK_SIZE, file.size);
        let chunkBlob = file.slice(start, end);
        log(`Compressing chunk ${i+1}/${chunkCount} (${((end-start)/1024).toFixed(0)} KB)...`);
        try {
          let zipBlob = await makeZipFromBlob(chunkBlob);
          chunkMeta[i].zipBlob = zipBlob;
        } catch(e) {
          log(`Failed to zip chunk ${i+1}.`, false, true);
          chunkMeta[i].status = "Failed";
          renderChunkList(chunkMeta);
          continue;
        }
        log(`Uploading chunk ${i+1}...`);
        let uploadOK = await sendZipToTelegram(chunkMeta[i].zipBlob, i);
        if(uploadOK) {
          log(`Chunk ${i+1} sent successfully.`, true);
          chunkMeta[i].status = "Success";
          sentCount++;
        } else {
          log(`Error sending chunk ${i+1}.`, false, true);
          chunkMeta[i].status = "Failed";
        }
        renderChunkList(chunkMeta);
        updateProgressBar((sentCount / chunkCount) * 100);
      }
      const failCount = chunkMeta.filter(c => c.status === "Failed").length;
      if(failCount === 0) log(`All chunks sent!`, true, false);
      else log(`Upload completed, ${failCount} chunk(s) failed. You can retry failed chunks.`, false, true);
    }

    async function retryChunk(idx) {
      log(`Retrying chunk ${idx+1}...`);
      chunkMeta[idx].status = "Pending";
      renderChunkList(chunkMeta);

      if(chunkMeta[idx].zipBlob == null) {
        // Get chunk again from file
        let start = idx * CHUNK_SIZE;
        let end = Math.min((idx+1)*CHUNK_SIZE, file.size);
        let chunkBlob = file.slice(start, end);
        try {
          let zipBlob = await makeZipFromBlob(chunkBlob);
          chunkMeta[idx].zipBlob = zipBlob;
        } catch(e) {
          log(`Failed to zip chunk ${idx+1}.`, false, true);
          chunkMeta[idx].status = "Failed";
          renderChunkList(chunkMeta);
          return;
        }
      }
      let uploadOK = await sendZipToTelegram(chunkMeta[idx].zipBlob, idx);
      if(uploadOK) {
        log(`Chunk ${idx+1} sent successfully.`, true);
        chunkMeta[idx].status = "Success";
      } else {
        log(`Error sending chunk ${idx+1}.`, false, true);
        chunkMeta[idx].status = "Failed";
      }
      renderChunkList(chunkMeta);
      const sentCount = chunkMeta.filter(c => c.status === "Success").length;
      updateProgressBar((sentCount / chunkMeta.length) * 100);
    }

    startBtn.onclick = chunkZipAndSend;
    fileInput.onchange = () => { resetUI(false); }
  </script>
</body>
</html>
